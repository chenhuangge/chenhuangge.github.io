<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My New Hugo Site</title>
    <link>https://chenhuangge.github.io/</link>
    <description>Recent content on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 05 Mar 2020 18:48:31 +0800</lastBuildDate>
    
	<atom:link href="https://chenhuangge.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Blog</title>
      <link>https://chenhuangge.github.io/post/blog/</link>
      <pubDate>Thu, 05 Mar 2020 18:48:31 +0800</pubDate>
      
      <guid>https://chenhuangge.github.io/post/blog/</guid>
      <description>一个几乎必问的面试题
在面试 Java初级开发的时候，经常会问的一个问题是：你有没有重写过 hashcode方法？不少候选人直接说没写过。或许真的是没写过，于是还可以再通过一个问题确认：你在用HashMap的时候，键（ Key）部分，有没有放过自定义对象？而这个时候，候选人说放过，于是两个问题的回答就自相矛盾了。
其实很多人这个问题普遍回答得都不大好，于是在本文里，就干脆 从 hash表讲起，讲述HashMap的存数据规则，由此大家就自然清楚上述问题的答案了。
再过一遍Hash算法
先复习一下数据结构里的一个知识点：在一个长度为 n（假设是 10000）的线性表（假设是ArrayList）里，存放着无序的数字；如果我们要找一个指定的数字，就不得不通过从头到尾依次遍历来查找。
我们再来观察Hash表（这里的Hash表纯粹是数据结构上的概念，和Java无关）。它的平均查找次数接近于 1，代价相当小，关键是在Hash表里，存放在其中的数据和它的存储位置是用Hash函数关联的。
我们假设一个Hash函数是 x*x%5。当然实际情况里不可能用这么简单的Hash函数，这里纯粹为了说明方便，而Hash表是一个长度是 11的线性表。如果我们要把 6放入其中，那么我们首先会对 6用Hash函数计算一下，结果是 1，所以我们就把 6放入到索引号是 1这个位置。同样如果我们要放数字 7，经过Hash函数计算， 7的结果是 4，那么它将被放入索引是 4的这个位置。这个效果如下图所示。
这样做的好处非常明显。比如我们要从中找 6这个元素，我们可以先通过Hash函数计算 6的索引位置，然后直接从 1号索引里找到它了。
不过我们会遇到“Hash值冲突”这个问题。比如经过Hash函数计算后， 7和 8会有相同的Hash值，对此Java的HashMap对象采用的是&amp;quot;链地址法&amp;quot;的解决方案。效果如下图所示
具体的做法是，为所有Hash值是 i的对象建立一个同义词链表。假设我们在放入 8的时候，发现 4号位置已经被占，那么就会新建一个链表结点放入 8。同样，如果我们要找 8，那么发现 4号索引里不是 8，那会沿着链表依次查找。
虽然我们还是无法彻底避免Hash值冲突的问题，但是Hash函数设计合理，仍能保证同义词链表的长度被控制在一个合理的范围里。这里讲的理论知识并非无的放矢，大家能在后文里清晰地了解到重写hashCode方法的重要性。
为毛要重写equals和hashCode方法 当我们用 HashMap存入自定义的类时，如果不重写这个自定义类的equals和hashCode方法，得到的结果会和我们预期的不一样。我们来看 WithoutHashCode.java这个例子。
在其中的第 2到第 18行，我们定义了一个 Key类；在其中的第 3行定义了唯一的一个属性 id。当前我们先注释掉第 9行的 equals方法和第 16行的 hashCode方法。
在 main函数里的第 22和 23行，我们定义了两个 Key对象，它们的 id都是 1，就好比它们是两把相同的都能打开同一扇门的钥匙。
在第 24行里，我们通过泛型创建了一个HashMap对象。它的键部分可以存放 Key类型的对象，值部分可以存储String类型的对象。
在第 25行里，我们通过 put方法把 k1和一串字符放入到 hm里；而在第 26行，我们想用 k2去从HashMap里得到值；这就好比我们想用 k1这把钥匙来锁门，用 k2来开门。这是符合逻辑的，但从当前结果看， 26行的返回结果不是我们想象中的那个字符串，而是 null。</description>
    </item>
    
  </channel>
</rss>